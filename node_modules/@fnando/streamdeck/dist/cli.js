"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const bundle_1 = require("./cli/bundle");
const create_1 = require("./cli/create");
const images_1 = require("./cli/images");
const debug_1 = require("./cli/debug");
const release_1 = require("./cli/release");
const docs_1 = require("./cli/docs");
const styleGuide_1 = require("./cli/styleGuide");
const linking_1 = require("./cli/linking");
(0, yargs_1.default)(process.argv.slice(2))
    .usage("Usage: $0 <command> [options]")
    .command("bundle", "Build files under `build` directory. While developing, use `--dev` to generate the files that can be linked to Stream Deck's plugins directory. It'll generate the `.streamDeckPlugin` otherwise.", (yargs) => yargs.options({
    dev: {
        type: "boolean",
        describe: "Build files without generating the .streamDeckPlugin file.",
    },
}), (argv) => (0, bundle_1.bundle)(argv))
    .command("release", "Release a new version of the plugin. This command will export a new bundle, make a new commit, tag it with the provided version, alter CHANGELOG.md, and push to your Git's repo origin source.", (yargs) => yargs.version(false).options({
    version: {
        type: "string",
        demandOption: true,
        describe: "The version to be release, following semantic versioning (e.g. 1.0.0)",
    },
}), (argv) => (0, release_1.release)(argv))
    .command("create [path]", "Create a new Stream Deck extension", (yargs) => yargs
    .positional("path", {
    type: "string",
    describe: "The extension path.",
    demandOption: true,
})
    .options({
    name: {
        demandOption: true,
        describe: "The human-readable name of the extension.",
        type: "string",
    },
    id: {
        demandOption: true,
        describe: "A reversed-DNS format that identifies the extension.",
        type: "string",
    },
    author: { describe: "The author name.", default: "" },
    email: { describe: "The author email.", default: "" },
    url: { describe: "The extension url.", default: "" },
    description: {
        describe: "The extension description.",
        default: "Your new Stream Deck plugin",
    },
    github: {
        default: "",
        describe: "Your Github user. When present, an origin pointing to Github will be added.",
    },
    gitlab: {
        default: "",
        describe: "Your Gitlab user. When present, an origin pointing to Gitlab will be added.",
    },
    install: {
        default: true,
        describe: "Install dependencies using npm.",
    },
}), (argv) => (0, create_1.create)(argv))
    .command("images", "Create file with embedded images", (_argv) => (0, images_1.images)())
    .command("link", "Link the dist directory to Stream Deck's plugin directory.", (yargs) => yargs.options({
    force: {
        type: "boolean",
        describe: "Replace installed extension, if any.",
    },
}), (argv) => (0, linking_1.link)(argv))
    .command("unlink", "Remove the Stream Deck directory's link.", (_argv) => (0, linking_1.unlink)())
    .command("docs", "Open Elgato's docs.", (_argv) => (0, docs_1.docs)())
    .command("styleguide", "Show Elgato's style guide", (_argv) => (0, styleGuide_1.styleGuide)())
    .command("debug [action]", "Manage debugging mode.", (yargs) => yargs.positional("action", {
    choices: ["open", "enable", "disable"],
    type: "string",
    default: "open",
}), (argv) => (0, debug_1.debug)({ action: argv.action }))
    .help()
    .strictCommands()
    .demandCommand(1)
    .parse();
//# sourceMappingURL=cli.js.map