"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const bundle_1 = require("./bundle");
const exec_1 = require("./helpers/exec");
const die_1 = require("./helpers/die");
function release(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        const streamDeckConfigPath = path_1.default.join(cwd, "src", "streamdeck.json");
        if (!fs_1.default.existsSync(streamDeckConfigPath)) {
            (0, die_1.die)(`ERROR: Expected "src/streamdeck.json" to be a file.`);
        }
        const config = require(streamDeckConfigPath);
        fs_1.default.writeFileSync(streamDeckConfigPath, JSON.stringify(Object.assign(Object.assign({}, config), { version: params.version }), null, 2));
        yield (0, bundle_1.bundle)({ dev: false });
        yield new Promise((resolve) => setTimeout(resolve, 1000));
        const changelogPath = path_1.default.join(cwd, "CHANGELOG.md");
        let changelog = fs_1.default.readFileSync(changelogPath).toString("utf-8");
        if (!params.version.match(/^\d+\.\d+\.\d+$/)) {
            (0, die_1.die)("ERROR: Version must be a semantic versioning string like 1.0.0");
        }
        if (!changelog.includes("## Unreleased")) {
            (0, die_1.die)(`ERROR: Couldn't find the "## Unreleased" section of your changelog.`);
        }
        const date = new Date().toISOString().substring(0, 10);
        changelog = changelog.replace("## Unreleased", `## v${params.version} - ${date}`);
        fs_1.default.writeFileSync(changelogPath, changelog);
        (0, exec_1.exec)("git", ["add", "src/streamdeck.json", "CHANGELOG.md", "release/"], {
            error: "Couldn't add files to Git's stage.",
            cwd,
        });
        (0, exec_1.exec)("git", ["commit", "--message", `Release v${params.version}.`], {
            error: "Couldn't commit files.",
            cwd,
        });
        (0, exec_1.exec)("git", ["tag", `v${params.version}`], {
            error: "Couldn't tag commit.",
            cwd,
        });
        (0, exec_1.exec)("git", ["push"], { error: "Couldn't push code.", cwd });
        (0, exec_1.exec)("git", ["push", "--tags"], { error: "Couldn't push tags.", cwd });
        console.log(`${config.name} v${params.version} has been released.`);
    });
}
exports.release = release;
//# sourceMappingURL=release.js.map