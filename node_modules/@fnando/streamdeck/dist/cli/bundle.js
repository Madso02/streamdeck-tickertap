"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const image_size_1 = __importDefault(require("image-size"));
const glob_1 = require("glob");
const esbuild_1 = require("esbuild");
const zip_dir_1 = __importDefault(require("zip-dir"));
const __1 = require("..");
const die_1 = require("./helpers/die");
const sourceDir = path_1.default.join(process.cwd(), "src");
const isFile = (name, rootDir) => {
    var _a;
    return Boolean((_a = fs_1.default.statSync(path_1.default.join(rootDir, name), { throwIfNoEntry: false })) === null || _a === void 0 ? void 0 : _a.isFile());
};
const assert = (passed, message) => {
    if (passed) {
        return;
    }
    console.error("ERROR:", message);
    process.exit(1);
};
const assertFile = (name, rootDir) => {
    assert(isFile(name, rootDir), `Expected "src/${name.replace(".js", ".ts")}" to exist.`);
};
const assertImageSize = (name, size, distDir) => {
    try {
        const dimensions = (0, image_size_1.default)(path_1.default.join(distDir, name));
        if (dimensions.width === size && dimensions.height === size) {
            return;
        }
        assert(false, `Expected "src/${name}" to be ${size}x${size} (got ${dimensions.width}x${dimensions.height}).`);
    }
    catch (error) {
        assert(false, `Expected "src/${name}" to be ${size}x${size} (error: ${error.message}).`);
    }
};
const assertImages = (name, { distDir, size, optional = false, extensions = ["png", "gif", "jpg"], } = { distDir: "", size: 0 }) => {
    for (const extension of extensions) {
        const lowResImagePath = `${name}.${extension}`;
        const hiResImagePath = `${name}@2x.${extension}`;
        const lowResImageExists = isFile(lowResImagePath, distDir);
        const hiResImageExists = isFile(hiResImagePath, distDir);
        if (lowResImageExists && hiResImageExists) {
            assertImageSize(lowResImagePath, size, distDir);
            assertImageSize(hiResImagePath, size * 2, distDir);
            return;
        }
        if (lowResImageExists && !hiResImageExists) {
            assert(false, `Expected "src/${hiResImagePath}" to be a file.`);
        }
        if (!lowResImageExists && hiResImageExists) {
            assert(false, `Expected "src/${lowResImagePath}" to be a file.`);
        }
    }
    if (optional) {
        return;
    }
    assert(false, `Expected "src/${name}.{${extensions.join(",")}}" and ` +
        `"src/${name}@2x.{${extensions.join(",")}}" to be set.`);
};
function assertState(_plugin, _action, state, distDir) {
    const actionName = state.action.constructor.name;
    const stateName = state.title || state.name || "<unnamed>";
    assert(Boolean(state.image), `Expect state "${stateName}" from "${actionName}" to have an image`);
    if (state.fontSize > 18) {
        assert(false, `Expect state "${stateName}" from "${actionName}" to have font size up to 18`);
    }
    assertImages(`images/actions/${actionName}/${state.image}`, {
        distDir,
        size: 72,
    });
    assertImages(`images/multiActions/${actionName}/${state.image}`, {
        distDir,
        size: 72,
        optional: true,
    });
}
function assertAction(plugin, action, distDir) {
    const actionName = action.constructor.name;
    assertFile(`actions/${actionName}.ts`, sourceDir);
    assertImages(`images/actions/${actionName}`, { size: 20, distDir });
    assert(action.states.length > 0, `Expected the action "${actionName}" to have at least 1 state.`);
    assert(Boolean(action.name), `Expected the action "${actionName}" to set a name.`);
    if (action.inspectorName) {
        assertFile(`inspectors/${action.inspectorName}.html`, sourceDir);
        assertFile(`inspectors/${action.inspectorName}.ts`, sourceDir);
    }
    action.states.forEach((state) => assertState(plugin, action, state, distDir));
}
function validate(plugin, distDir) {
    assertImages("images/plugin", { size: 72, distDir });
    assertImages("images/category", {
        distDir,
        optional: true,
        extensions: ["png"],
        size: 28,
    });
    assert(Boolean(plugin.version), "Expected plugin to define `version`.");
    assert(plugin.actions.length > 0, "Expected plugin to have at least 1 action.");
    assert(plugin.os.length > 0, "Expected plugin to set OS requirements.");
    plugin.actions.forEach((action) => assertAction(plugin, action, distDir));
}
function compile(distDir, params) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_1.default.rmSync(path_1.default.resolve("build"), { recursive: true, force: true });
        yield (0, esbuild_1.build)({
            entryPoints: [`${sourceDir}/plugin.ts`],
            bundle: true,
            keepNames: true,
            format: "cjs",
            target: "node16",
            logLevel: "silent",
            outfile: `${distDir}/plugin-node.js`,
            define: {
                __DEV__: JSON.stringify(params.dev),
            },
        });
        fs_1.default.writeFileSync(`${distDir}/run.ts`, `
    import plugin from "../../src/plugin";
    plugin.run();
    `);
        const inspectors = (0, glob_1.sync)(`${sourceDir}/inspectors/*.ts`);
        const entryPoints = [
            path_1.default.join(sourceDir, "plugin.ts"),
            path_1.default.join(distDir, "run.ts"),
            path_1.default.join(sourceDir, "inspector.ts"),
            ...inspectors,
        ];
        yield (0, esbuild_1.build)({
            entryPoints,
            bundle: true,
            keepNames: true,
            platform: "browser",
            logLevel: "silent",
            outdir: distDir,
            define: {
                __DEV__: JSON.stringify(params.dev),
            },
        });
        (0, glob_1.sync)(`${distDir}/{src,build}/**/*.js`).forEach((filePath) => {
            fs_1.default.renameSync(filePath, path_1.default.join(distDir, path_1.default.basename(filePath)));
        });
        (0, glob_1.sync)(`${sourceDir}/locales/*.json`).forEach((filePath) => {
            try {
                const content = JSON.stringify(fs_1.default.readFileSync(filePath).toString("utf-8"));
                if (!content || (content === null || content === void 0 ? void 0 : content.constructor) !== Object) {
                    throw new Error("Invalid JSON file.");
                }
            }
            catch (e) {
                (0, die_1.die)(`ERROR: The file "${path_1.default.relative(process.cwd(), filePath)}" is not a valid JSON file (expected an object).`);
            }
            fs_1.default.copyFileSync(filePath, path_1.default.join(distDir, path_1.default.basename(filePath)));
        });
        fs_1.default.mkdirSync(path_1.default.join(distDir, "inspectors"), { recursive: true });
        inspectors.forEach((filePath) => {
            const fileName = path_1.default.basename(filePath).replace(".ts", ".js");
            fs_1.default.renameSync(path_1.default.join(distDir, fileName), path_1.default.join(distDir, "inspectors", fileName));
        });
        fs_1.default.renameSync(`${distDir}/run.js`, `${distDir}/plugin.js`);
        fs_1.default.rmSync(`${distDir}/dist`, { recursive: true, force: true });
        fs_1.default.rmSync(`${distDir}/build`, { recursive: true, force: true });
        fs_1.default.rmSync(`${distDir}/src`, { recursive: true, force: true });
        fs_1.default.rmSync(`${distDir}/run.ts`, { recursive: true, force: true });
        fs_1.default.copyFileSync(`${sourceDir}/inspector.html`, `${distDir}/inspector.html`);
        (0, glob_1.sync)(path_1.default.join(sourceDir, "inspectors/*.html")).forEach((filePath) => {
            fs_1.default.copyFileSync(filePath, `${distDir}/inspectors/${path_1.default.basename(filePath)}`);
        });
        const filesToCopy = (0, glob_1.sync)(`${sourceDir}/{images,css,previews}/**/*.*`);
        filesToCopy.sort();
        filesToCopy.forEach((filePath) => {
            const targetPath = path_1.default.join(distDir, path_1.default.relative(path_1.default.join(process.cwd(), "src"), filePath));
            fs_1.default.mkdirSync(path_1.default.dirname(targetPath), { recursive: true });
            fs_1.default.copyFileSync(filePath, targetPath);
        });
        fs_1.default.writeFileSync(`${distDir}/plugin.html`, '<script src="plugin.js"></script>');
    });
}
function archive(pluginId, distDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const outputPath = path_1.default.join(process.cwd(), "release", `${pluginId}.streamDeckPlugin`);
        fs_1.default.rmSync(outputPath, { force: true });
        fs_1.default.mkdirSync(path_1.default.dirname(outputPath), { recursive: true });
        yield (0, zip_dir_1.default)(path_1.default.dirname(distDir), { saveTo: outputPath });
    });
}
function bundle(params) {
    return __awaiter(this, void 0, void 0, function* () {
        assertFile("streamdeck.json", sourceDir);
        assertFile("plugin.ts", sourceDir);
        assertFile("inspector.html", sourceDir);
        assertFile("inspector.ts", sourceDir);
        assertFile("css/sdpi.css", sourceDir);
        assertFile("css/custom.css", sourceDir);
        assertFile("CHANGELOG.md", process.cwd());
        const config = require(`${sourceDir}/streamdeck.json`);
        const distDir = path_1.default.resolve(params.dev
            ? `build/dev.${config.id}.sdPlugin`
            : `build/${config.id}.sdPlugin`);
        const pluginPath = path_1.default.join(distDir, "plugin-node.js");
        yield compile(distDir, params);
        const plugin = require(pluginPath);
        assert(!(plugin.default instanceof __1.Plugin), `Expected the default export to be an instance of Plugin.`);
        validate(plugin.default, distDir);
        const manifest = plugin.default.toManifest();
        if (config.monitor) {
            manifest.ApplicationsToMonitor = config.monitor;
        }
        fs_1.default.writeFileSync(`${distDir}/manifest.json`, JSON.stringify(manifest, null, 2));
        fs_1.default.rmSync(pluginPath);
        if (!params.dev) {
            yield archive(plugin.default.id, distDir);
        }
    });
}
exports.bundle = bundle;
//# sourceMappingURL=bundle.js.map